"""
CSV Data Loader for ETF Scoring Application
Replaces real-time calculations with CSV file reading
"""

import csv
import os
import logging
from datetime import datetime
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

class CsvDataLoader:
    """Loads ETF scoring data from CSV files generated by the bulk calculator"""
    
    def __init__(self, csv_file_path: str = None):
        # Default CSV file path - can be overridden by environment variable
        self.csv_file_path = csv_file_path or os.environ.get('ETF_SCORES_CSV', 'etf_scores.csv')
        self.last_loaded_time = None
        self.cached_data = {}
        self.cache_duration = 300  # 5 minutes cache
        
        # ETF sector mappings (keep the same as current application)
        self.etf_sectors = {
            "XLK": "Technology",
            "XLF": "Financial", 
            "XLV": "Health Care",
            "XLI": "Industrial",
            "XLP": "Consumer Staples",
            "XLY": "Consumer Discretionary",
            "XLE": "Energy",
            "XLB": "Materials",
            "XLU": "Utilities",
            "XLRE": "Real Estate",
            "XLC": "Communication Services"
        }
    
    def load_csv_data(self) -> Dict:
        """
        Load ETF scoring data from CSV file
        
        Returns:
            Dictionary with ETF data in the exact same format as current application
        """
        try:
            if not os.path.exists(self.csv_file_path):
                logger.warning(f"CSV file not found: {self.csv_file_path}")
                return self._get_default_data()
            
            logger.info(f"Loading ETF data from {self.csv_file_path}")
            etf_data = {}
            
            with open(self.csv_file_path, 'r', newline='') as csvfile:
                reader = csv.DictReader(csvfile)
                
                for row in reader:
                    symbol = row['symbol'].upper()
                    
                    # Convert CSV data to the exact format expected by frontend
                    indicators = {
                        'trend1': {
                            'pass': self._str_to_bool(row['trend1_pass']),
                            'current': float(row['trend1_current']),
                            'threshold': float(row['trend1_threshold']),
                            'description': row['trend1_description']
                        },
                        'trend2': {
                            'pass': self._str_to_bool(row['trend2_pass']),
                            'current': float(row['trend2_current']),
                            'threshold': float(row['trend2_threshold']),
                            'description': row['trend2_description']
                        },
                        'snapback': {
                            'pass': self._str_to_bool(row['snapback_pass']),
                            'current': float(row['snapback_current']),
                            'threshold': float(row['snapback_threshold']),
                            'description': row['snapback_description']
                        },
                        'momentum': {
                            'pass': self._str_to_bool(row['momentum_pass']),
                            'current': float(row['momentum_current']),
                            'threshold': float(row['momentum_threshold']),
                            'description': row['momentum_description']
                        },
                        'stabilizing': {
                            'pass': self._str_to_bool(row['stabilizing_pass']),
                            'current': float(row['stabilizing_current']),
                            'threshold': float(row['stabilizing_threshold']),
                            'description': row['stabilizing_description']
                        }
                    }
                    
                    etf_data[symbol] = {
                        "name": self.etf_sectors.get(symbol, "Unknown Sector"),
                        "score": int(row['total_score']),
                        "price": float(row['current_price']),
                        "indicators": indicators,
                        "calculation_timestamp": row.get('calculation_timestamp', ''),
                        "data_age_hours": int(row.get('data_age_hours', 0))
                    }
            
            logger.info(f"Successfully loaded {len(etf_data)} ETF records from CSV")
            self.last_loaded_time = datetime.now()
            self.cached_data = etf_data
            return etf_data
            
        except Exception as e:
            logger.error(f"Failed to load CSV data: {e}")
            return self._get_default_data()
    
    def _str_to_bool(self, value: str) -> bool:
        """Convert string boolean values from CSV to actual booleans"""
        if isinstance(value, bool):
            return value
        return str(value).lower() in ('true', '1', 'yes', 'on')
    
    def _get_default_data(self) -> Dict:
        """Return default data structure when CSV is not available"""
        default_indicators = {
            'trend1': {'pass': False, 'current': 0, 'threshold': 0, 'description': 'Data loading...'},
            'trend2': {'pass': False, 'current': 0, 'threshold': 0, 'description': 'Data loading...'},
            'snapback': {'pass': False, 'current': 0, 'threshold': 0, 'description': 'Data loading...'},
            'momentum': {'pass': False, 'current': 0, 'threshold': 0, 'description': 'Data loading...'},
            'stabilizing': {'pass': False, 'current': 0, 'threshold': 0, 'description': 'Data loading...'}
        }
        
        return {
            "XLC": {"name": "Communication Services", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLF": {"name": "Financial", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLV": {"name": "Health Care", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLI": {"name": "Industrial", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLP": {"name": "Consumer Staples", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLY": {"name": "Consumer Discretionary", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLE": {"name": "Energy", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLB": {"name": "Materials", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLU": {"name": "Utilities", "score": 0, "price": 0.00, "indicators": default_indicators.copy()},
            "XLRE": {"name": "Real Estate", "score": 0, "price": 0.00, "indicators": default_indicators.copy()}
        }
    
    def get_etf_data(self, force_refresh: bool = False) -> Dict:
        """
        Get ETF data with caching
        
        Args:
            force_refresh: Whether to force reload from CSV
            
        Returns:
            Dictionary with ETF data
        """
        now = datetime.now()
        
        # Check if we need to refresh the cache
        if (force_refresh or 
            not self.cached_data or 
            not self.last_loaded_time or
            (now - self.last_loaded_time).total_seconds() > self.cache_duration):
            
            return self.load_csv_data()
        
        return self.cached_data
    
    def get_csv_status(self) -> Dict:
        """Get information about the CSV file status"""
        try:
            if os.path.exists(self.csv_file_path):
                stat = os.stat(self.csv_file_path)
                return {
                    'exists': True,
                    'size': stat.st_size,
                    'modified': datetime.fromtimestamp(stat.st_mtime),
                    'path': self.csv_file_path
                }
            else:
                return {
                    'exists': False,
                    'path': self.csv_file_path
                }
        except Exception as e:
            logger.error(f"Error checking CSV status: {e}")
            return {'exists': False, 'error': str(e)}